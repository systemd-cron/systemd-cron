#!/usr/bin/python3
import sys
import os
import pwd
import re
import string
from functools import reduce
import hashlib

envvar_re = re.compile(r'^([A-Za-z_0-9]+)\s*=\s*(.*)$')

MINUTES_SET = list(range(0, 60))
HOURS_SET = list(range(0, 24))
DAYS_SET = list(range(0, 32))
DOWS_SET = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
MONTHS_SET = list(range(0, 13))
TIME_UNITS_SET = ['daily', 'weekly', 'monthly', 'quarterly', 'semi-annually', 'yearly']

KSH_SHELLS = ['/bin/sh', '/bin/dash', '/bin/ksh', '/bin/bash', '/usr/bin/zsh']
REBOOT_FILE = '/run/crond.reboot'

def files(dirname):
    try:
        return list(filter(os.path.isfile, [os.path.join(dirname, f) for f in os.listdir(dirname)]))
    except OSError:
        return []

def expand_home_path(path, user):
    try:
        home = pwd.getpwnam(user).pw_dir
    except KeyError:
        return path

    parts = path.split(':')
    for i, part in enumerate(parts):
        if part.startswith('~/'):
            parts[i] = home + part[1:]
    return ':'.join(parts)

def parse_crontab(filename, withuser=True, monotonic=False):
    basename = os.path.basename(filename)
    environment = { }
    random_delay = 1
    start_hours_range = '0'
    persistent = False
    persistent = True # '@persistent@' this line can be removed by sed depending on build options
    with open(filename, 'r') as f:
        for line in f.readlines():
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            envvar = envvar_re.match(line)
            if envvar:
                value = envvar.group(2)
                value = value.strip("'").strip('"')
                if envvar.group(1) == 'RANDOM_DELAY':
                     random_delay = value
                elif envvar.group(1) == 'START_HOURS_RANGE':
                     start_hours_range = value
                elif envvar.group(1) == 'PERSISTENT':
                     persistent = {'true': True, 'yes': True, '1': True}.get(value.lower(), False)
                elif not withuser and envvar.group(1) == 'PATH':
                     environment['PATH'] = expand_home_path(value, basename)
                else:
                     environment[envvar.group(1)] = value
                continue

            parts = line.split()
            line = ' '.join(parts)

            if monotonic:
                if len(parts) < 4:
                    continue

                period, boot_delay, jobid = parts[0:3]
                command = ' '.join(parts[3:])
                period = {
                        '1': 'daily',
                        '@midnight': 'daily',
                        '7': 'weekly',
                        '30': 'monthly',
                        '31': 'monthly',
                        '@biannually': 'semi-annually',
                        '@bi-annually': 'semi-annually',
                        '@semiannually': 'semi-annually',
                        '@anually': 'yearly',
                        '@annually': 'yearly',
                        }.get(period, None) or period.lstrip('@')
                valid_chars = "-_%s%s" % (string.ascii_letters, string.digits)
                jobid = ''.join(c for c in jobid if c in valid_chars)

                yield {
                        'e': ' '.join('"%s=%s"' % kv for kv in environment.items()),
                        's': environment.get('SHELL','/bin/sh'),
                        'a': random_delay,
                        'l': line,
                        'f': filename,
                        'p': period.lower(),
                        'b': boot_delay,
                        'h': start_hours_range,
                        'P': persistent,
                        'j': jobid,
                        'u': 'root',
                        'c': command
                        }

            else:
                if line.startswith('@'):
                    if len(parts) < 2 + int(withuser):
                        continue

                    period = parts[0]
                    period = {
                            '@midnight': 'daily',
                            '@biannually': 'semi-annually',
                            '@bi-annually': 'semi-annually',
                            '@semiannually': 'semi-annually',
                            '@anually': 'yearly',
                            '@annually': 'yearly',
                            }.get(period, None) or period.lstrip('@')

                    user, command = (parts[1], ' '.join(parts[2:])) if withuser else (basename, ' '.join(parts[1:]))

                    yield {
                            'e': ' '.join('"%s=%s"' % kv for kv in environment.items()),
                            's': environment.get('SHELL','/bin/sh'),
                            'a': random_delay,
                            'l': line,
                            'f': filename,
                            'p': period.lower(),
                            'h': start_hours_range,
                            'P': persistent,
                            'j': basename,
                            'u': user,
                            'c': command
                            }
                else:
                    if len(parts) < 6 + int(withuser):
                        continue

                    minutes, hours, days = parts[0:3]
                    months, dows = parts[3:5]
                    user, command = (parts[5], ' '.join(parts[6:])) if withuser else (basename, ' '.join(parts[5:]))

                    yield {
                            'e': ' '.join('"%s=%s"' % kv for kv in environment.items()),
                            's': environment.get('SHELL','/bin/sh'),
                            'a': random_delay,
                            'l': line,
                            'f': filename,
                            'm': parse_time_unit(minutes, MINUTES_SET),
                            'h': parse_time_unit(hours, HOURS_SET),
                            'd': parse_time_unit(days, DAYS_SET),
                            'w': parse_time_unit(dows, DOWS_SET, dow_map),
                            'M': parse_time_unit(months, MONTHS_SET, month_map),
                            'P': persistent,
                            'j': basename,
                            'u': user,
                            'c': command
                            }

def parse_time_unit(value, values, mapping=int):
    if value == '*':
        return ['*']
    return sorted(list(reduce(lambda a, i: a.union(set(i)), list(map(values.__getitem__,
        list(map(parse_period(mapping), value.split(','))))), set())))

def month_map(month):
    try:
        return int(month)
    except ValueError:
        return ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'nov', 'dec'].index(month.lower()[0:3]) + 1

def dow_map(dow):
    try:
        return ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'].index(dow[0:3].lower())
    except ValueError:
        return int(dow) % 7

def parse_period(mapping=int):
    def parser(value):
        try:
            range, step = value.split('/')
        except ValueError:
            range = value
            step = 1

        if range == '*':
            return slice(None, None, int(step))

        try:
            start, end = range.split('-')
        except ValueError:
            start = end = range

        return slice(mapping(start), mapping(end) + 1, int(step))

    return parser

def generate_timer_unit(job, seq):
    persistent = job['P']

    command=job['c']
    parts = command.split()
    testremoved = None

    standardoutput = ''

    try:
        home = pwd.getpwnam(job['u']).pw_dir
    except KeyError:
        home = ''
        pass

    # perform smart substitutions for known shells
    if job['s'] in KSH_SHELLS:
        if home and command.startswith('~/'):
            command = home + command[1:]

        if (len(parts) >= 3 and
            parts[-2] == '>' and
            parts[-1] == '/dev/null'):
            command = ' '.join(parts[0:-2])
            parts = command.split()
            standardoutput='null';

        if (len(parts) >= 2 and
            parts[-1] == '>/dev/null'):
            command = ' '.join(parts[0:-1])
            parts = command.split()
            standardoutput='null';

        if (len(parts) == 6 and
            parts[0] == '[' and
            parts[1] in ['-x','-f','-e'] and
            parts[2] == parts[5] and
            parts[3] == ']' and
            parts[4] == '&&' ):
                testremoved = parts[2]
                command = ' '.join(parts[5:])
                parts = command.split()

        if (len(parts) == 5 and
            parts[0] == 'test' and
            parts[1] in ['-x','-f','-e'] and
            parts[2] == parts[4] and
            parts[3] == '&&' ):
                testremoved = parts[2]
                command = ' '.join(parts[4:])
                parts = command.split()

        if testremoved and not os.path.isfile(testremoved): return

        # TODO: translate  'command%line1%line2%line3
        # in '/bin/echo -e line1\\nline2\\nline3 | command'
        # to be POSIX compliant

    if not (len(parts) == 1 and os.path.isfile(command)):
        command=job['s'] + " -c '" + command + "'"

    # validate user input
    try:
        accuracy = int(job['a'])
    except ValueError:
        accuracy = 1

    try:
       delay = int(job['b'])
    except KeyError:
       delay = 0
    except ValueError:
       delay = 0
    if delay < 0:
       delay = 0


    if 'p' in job:
        try:
           parts = job['h'].split('-')
           hour = int(parts[0])
        except ValueError:
           hour = 0

        if job['p'] == 'reboot':
            if os.path.isfile(REBOOT_FILE): return
            if delay == 0: delay = 1
            schedule = ''
            persistent = False
        elif job['p'] == 'minutely':
            schedule = job['p']
            persistent = False
        elif job['p'] == 'hourly':
            if delay == 0: schedule = 'hourly'
            else: schedule = '*-*-* *:%s:0' % delay
            persistent = False
            delay = 0
        elif job ['p'] in TIME_UNITS_SET and hour == 0 and delay == 0:
            schedule = job['p']
        elif job['p'] == 'daily':
            schedule = '*-*-* %s:%s:0' % (hour, delay)
        elif job['p'] == 'weekly':
            schedule = 'Mon *-*-* %s:%s:0' % (hour, delay)
        elif job['p'] == 'monthly':
            schedule = '*-*-1 %s:%s:0' % (hour, delay)
        elif job['p'] == 'quarterly':
            schedule = '*-1,4,7,10-1 %s:%s:0' % (hour, delay)
        elif job['p'] == 'semi-annually':
            schedule = '*-1,7-1 %s:%s:0' % (hour, delay)
        elif job['p'] == 'yearly':
            schedule = '*-1-1 %s:%s:0' % (hour, delay)
        else:
            try:
               if int(job['p']) > 31:
                    # workaround for anacrontab
                    schedule = '*-1/%s-1 %s:%s:0' % (int(round(int(job['p']))/30), hour, delay)
               else:
                    schedule = '*-*-1/%s %s:%s:0' % (int(job['p']), hour, delay)
            except ValueError:
                    # this record is unexpected, pass it as-is to systemd
                    # that will complain loudly in the journal if appropriate;
                    # but the other lines are not affected
                    schedule = job['p']

    else:
        dows = ','.join(job['w'])
        dows = '' if dows == '*' else dows + ' '

        schedule = '%s*-%s-%s %s:%s:00' % (dows, ','.join(map(str, job['M'])),
                ','.join(map(str, job['d'])), ','.join(map(str, job['h'])), ','.join(map(str, job['m'])))
        if (job['M'] == ['*'] and
         job['w'] == ['*'] and
         job['d'] == ['*'] and
         job['h'] == ['*']):
            persistent = False

    if not persistent:
        unit_id = next(seq)
    else:
        unit_id = hashlib.md5()
        unit_id.update(bytes('\0'.join([schedule, command]), 'utf-8'))
        unit_id = unit_id.hexdigest()
    unit_name = "cron-%s-%s-%s" % (job['j'], job['u'], unit_id)

    with open('%s/%s.timer' % (TARGET_DIR, unit_name), 'w') as f:
        f.write('[Unit]\n')
        f.write('Description=[Timer] "%s"\n' % job['l'])
        f.write('Documentation=man:systemd-crontab-generator(8)\n')
        f.write('PartOf=cron.target\n')
        f.write('RefuseManualStart=true\n')
        f.write('RefuseManualStop=true\n')
        f.write('SourcePath=%s\n' % job['f'])
        if testremoved: f.write('ConditionFileIsExecutable=%s\n' % testremoved)

        f.write('\n[Timer]\n')
        f.write('Unit=%s.service\n' % unit_name)
        if schedule: f.write('OnCalendar=%s\n' % schedule)
        if accuracy != 1: f.write('AccuraySec=%sm\n' % accuracy)
        if persistent: f.write('Persistent=true\n')
        if delay: f.write("OnBootSec=%sm\n" % delay)

    try:
        os.symlink('%s/%s.timer' % (TARGET_DIR, unit_name), '%s/%s.timer' % (TIMERS_DIR, unit_name))
    except OSError as e:
        if e.errno != os.errno.EEXIST:
            raise

    with open('%s/%s.service' % (TARGET_DIR, unit_name), 'w') as f:
        f.write('[Unit]\n')
        f.write('Description=[Cron] "%s"\n' % job['l'])
        f.write('Documentation=man:systemd-crontab-generator(8)\n')
        f.write('RefuseManualStart=true\n')
        f.write('RefuseManualStop=true\n')
        f.write('SourcePath=%s\n' % job['f'])
        f.write('OnFailure=cron-failure@%i.service\n')
        if job['u'] != 'root' or job['f'] == '@statedir@/root':
            f.write('Requires=systemd-user-sessions.service\n')
            if home: f.write('RequiresMountsFor=%s\n' % home)

        f.write('\n[Service]\n')
        f.write('Type=oneshot\n')
        f.write('ExecStart=%s\n' % command)
        if job['e']: f.write('Environment=%s\n' % job['e'])
        if job['u'] != 'root': f.write('User=%s\n' % job['u'])
        if standardoutput: f.write('StandardOutput=%s\n' % standardoutput)

    return '%s.timer' % unit_name


seqs = {}
def count():
    n = 0
    while True:
        yield n
        n += 1

if __name__ == '__main__':
    try:
        TARGET_DIR = sys.argv[1]
    except IndexError:
        print("Usage: %s <destination_folder>" % sys.argv[0])
        exit(1)

    SELF = os.path.basename(sys.argv[0])
    TIMERS_DIR = os.path.join(TARGET_DIR, 'cron.target.wants')

    try:
        os.makedirs(TIMERS_DIR)
    except OSError as e:
        if e.errno != os.errno.EEXIST:
            raise

    try:
        for job in parse_crontab('/etc/crontab', withuser=True):
            generate_timer_unit(job, seqs.setdefault(job['j']+job['u'], count()))
    except IOError:
        pass

    CRONTAB_FILES = files('/etc/cron.d')
    for filename in CRONTAB_FILES:
        basename = os.path.basename(filename)
        if (os.path.isfile('@unitdir@/' + basename + '.timer')
         or os.path.isfile('/etc/systemd/system/' + basename + '.timer')):
            with open('/dev/kmsg', 'w') as log:
                log.write('%s ignoring %s\n' % (SELF , filename))
            continue
        try:
            for job in parse_crontab(filename, withuser=True):
                generate_timer_unit(job, seqs.setdefault(job['j']+job['u'], count()))
        except IOError:
            pass

    try:
        for job in parse_crontab('/etc/anacrontab', monotonic=True):
            generate_timer_unit(job, seqs.setdefault(job['j']+job['u'], count()))
    except IOError:
        pass


    if os.path.isdir('@statedir@'):
        # /var is avaible
        USERCRONTAB_FILES = files('@statedir@')
        for filename in USERCRONTAB_FILES:
            try:
                for job in parse_crontab(filename, withuser=False):
                    generate_timer_unit(job, seqs.setdefault(job['j']+job['u'], count()))
            except IOError:
                pass

        try:
            open(REBOOT_FILE,'a').close()
        except:
            pass
    else:
        # schedule rerun
        with open('%s/cron-after-var.service' % TARGET_DIR, 'w') as f:
            f.write('[Unit]\n')
            f.write('Description=Rerun systemd-crontab-generator because /var is a separate mount\n')
            f.write('Documentation=man:systemd.cron(7)\n')
            f.write('After=cron.target\n')
            f.write('ConditionDirectoryNotEmpty=@statedir@\n')

            f.write('\n[Service]\n')
            f.write('Type=oneshot\n')
            f.write('ExecStart=/bin/sh -c "/bin/systemctl daemon-reload ; /bin/systemctl try-restart cron.target"\n')

        MULTIUSER_DIR = os.path.join(TARGET_DIR, 'multi-user.target.wants')

        try:
           os.makedirs(MULTIUSER_DIR)
        except OSError as e:
           if e.errno != os.errno.EEXIST:
               raise

        try:
            os.symlink('%s/cron-after-var.service' % TARGET_DIR, '%s/cron-after-var.service' % MULTIUSER_DIR)
        except OSError as e:
            if e.errno != os.errno.EEXIST:
                raise
