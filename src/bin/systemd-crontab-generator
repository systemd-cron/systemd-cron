#!/usr/bin/python3
import sys
import os
import re
from functools import reduce

def files(dirname):
    try:
        return list(filter(os.path.isfile, [os.path.join(dirname, f) for f in os.listdir(dirname)]))
    except OSError:
        return []

envvar_re = re.compile(r'^([A-Za-z_0-9]+)\s*=\s*(.*)$')

CRONTAB_FILES = ['/etc/crontab'] + files('/etc/cron.d')
ANACRONTAB_FILES = ['/etc/anacrontab']
USERCRONTAB_FILES = files('@statedir@')

TARGER_DIR = sys.argv[1]
TIMERS_DIR = os.path.join(TARGER_DIR, 'cron.target.wants')
SELF = os.path.basename(sys.argv[0])

MINUTES_SET = list(range(0, 60))
HOURS_SET = list(range(0, 24))
DAYS_SET = list(range(0, 32))
DOWS_SET = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
MONTHS_SET = list(range(0, 13))
TIME_UNITS_SET = ['hourly', 'daily', 'weekly', 'monthly', 'yearly', 'annually']

try:
    os.makedirs(TIMERS_DIR)
except OSError as e:
    if e.errno != os.errno.EEXIST:
        raise

def parse_crontab(filename, withuser=True, monotonic=False):
    basename = os.path.basename(filename)
    environment = {
        'PATH': '/usr/bin:/bin',
        }
    random_delay = 1
    start_hours_range = 0
    with open(filename, 'r') as f:
        for line in f.readlines():
            if line.startswith('#'):
                continue

            line = line.rstrip('\n')
            envvar = envvar_re.match(line)
            if envvar:
                if envvar.group(1) == 'RANDOM_DELAY':
                     random_delay = envvar.group(2)
                elif envvar.group(1) == 'START_HOURS_RANGE':
                     start_hours_range = envvar.group(2)
                else:
                    environment[envvar.group(1)] = envvar.group(2)
                continue

            parts = line.split()
            line = ' '.join(parts)

            if monotonic:
                if len(parts) < 4:
                    continue

                period, delay, jobid = parts[0:3]
                command = ' '.join(parts[3:])
                period = {
                        '1': 'daily',
                        '7': 'weekly',
                        '@midnight': 'daily',
                        '30': 'monthly',
                        '31': 'monthly'
                        }.get(period, None) or period.lstrip('@')

                yield {
                        'e': ' '.join('"%s=%s"' % kv for kv in environment.items()),
                        's': environment.get('SHELL','/bin/sh'),
                        'a': random_delay,
                        'l': line,
                        'f': filename,
                        'p': period.lower(),
                        'd': delay,
                        'h': start_hours_range,
                        'j': jobid,
                        'c': command,
                        'u': 'root'
                        }

            else:
                if line.startswith('@'):
                    if len(parts) < 2:
                        continue

                    period = parts[0]
                    period = {
                            '@midnight': 'daily'
                            }.get(period, None) or period.lstrip('@')

                    user, command = (parts[1], ' '.join(parts[2:])) if withuser else (basename, ' '.join(parts[1:]))

                    yield {
                            'e': ' '.join('"%s=%s"' % kv for kv in environment.items()),
                            's': environment.get('SHELL','/bin/sh'),
                            'a': random_delay,
                            'l': line,
                            'f': filename,
                            'p': period.lower(),
                            'h': start_hours_range,
                            'u': user,
                            'c': command
                            }
                else:
                    if len(parts) < 6 + int(withuser):
                        continue

                    minutes, hours, days = parts[0:3]
                    months, dows = parts[3:5]
                    user, command = (parts[5], ' '.join(parts[6:])) if withuser else (basename, ' '.join(parts[5:]))

                    yield {
                            'e': ' '.join('"%s=%s"' % kv for kv in environment.items()),
                            's': environment.get('SHELL','/bin/sh'),
                            'a': random_delay,
                            'l': line,
                            'f': filename,
                            'm': parse_time_unit(minutes, MINUTES_SET),
                            'h': parse_time_unit(hours, HOURS_SET),
                            'd': parse_time_unit(days, DAYS_SET),
                            'w': parse_time_unit(dows, DOWS_SET, dow_map),
                            'M': parse_time_unit(months, MONTHS_SET, month_map),
                            'u': user,
                            'c': command
                            }

def parse_time_unit(value, values, mapping=int):
    if value == '*':
        return ['*']
    return sorted(list(reduce(lambda a, i: a.union(set(i)), list(map(values.__getitem__,
        list(map(parse_period(mapping), value.split(','))))), set())))

def month_map(month):
    try:
        return int(month)
    except ValueError:
        return ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'nov', 'dec'].index(month.lower()[0:3]) + 1

def dow_map(dow):
    try:
        return ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'].index(dow[0:3].lower())
    except ValueError:
        return int(dow) % 7

def parse_period(mapping=int):
    def parser(value):
        try:
            range, step = value.split('/')
        except ValueError:
            value = mapping(value)
            return slice(value, value + 1)

        if range == '*':
            return slice(None, None, int(step))

        try:
            start, end = range.split('-')
        except ValueError:
            return slice(mapping(range), None, int(step))

        return slice(mapping(start), mapping(end), int(step))

    return parser

def generate_timer_unit(job, seq):
    n = next(seq)
    unit_name = "cron-%s-%s" % (job['u'], n)

    persistent=''
    persistent='@persistent@' #this can be removed by sed depending on build options
    boot=''

    command=job['c']
    parts = command.split()
    testremoved = 0
    if (len(parts) >= 5 and
        parts[0] == '[' and
        parts[1] in ['-x','-f','-e'] and
        parts[2] == parts[5] and
        parts[3] == ']' and
        parts[4] == '&&' ):
        if os.path.isfile(parts[2]):
            command = ' '.join(parts[5:])
            parts = command.split()
            testremoved = 1
        else:
            return '%s.timer' % unit_name

    if (len(parts) >= 4 and
        parts[0] == 'test' and
        parts[1] in ['-x','-f','-e'] and
        parts[2] == parts[4] and
        parts[3] == '&&' ):
	if os.path.isfile(parts[2]):
            command = ' '.join(parts[4:])
            parts = command.split()
            testremoved = 1
        else:
            return '%s.timer' % unit_name

    if (len(parts) >= 3 and
        parts[-2] == '>' and
        parts[-1] == '/dev/null'):
        command = ' '.join(parts[0:-2])
        parts = command.split()
        standardoutput='null';
    else:
        standardoutput='journal';

    # TODO: translate  'command%line1%line2%line3
    # in '/bin/echo -e line1\\nline2\\nline3 | command'
    # to be POSIX compliant

    if not (len(parts) == 1 and
        os.path.isfile(command)):
	command=job['s'] + " -c '" + command + "'"
    elif testremoved:
        command='-' + command

    # validate user input
    try:
        accuracy = int(job['a'])
    except ValueError:
        accuracy = 1

    if 'p' in job:
        try:
           delay = int(job['d'])
        except KeyError:
           delay = 0
        except ValueError:
           delay = 0
	if delay > 0:
           boot = 'OnBootSec=%sm' % delay

        try:
           parts = job['h'].split('-')
           hour = int(parts[0])
        except ValueError:
           hour = 0

        if job['p'] == 'reboot':
            schedule = ''
            boot = 'OnBootSec=%sm' % job.get('d', 5)
            persistent = ''
        elif job ['p'] in TIME_UNITS_SET and delay == 0 and hour == 0:
            schedule = 'OnCalendar=%s' % job['p']
        elif job['p'] == 'hourly':
            schedule = 'OnCalendar=*-*-* *:%s:0' % delay
            boot = ''
        elif job['p'] == 'daily':
            schedule = 'OnCalendar=*-*-* %s:%s:0' % (hour, delay)
        elif job['p'] == 'weekly':
            schedule = 'OnCalendar=Mon *-*-* %s:%s:0' % (hour, delay)
        elif job['p'] == 'monthly':
            schedule = 'OnCalendar=*-*-1 %s:%s:0' % (hour, delay)
        elif job['p'] == 'yearly' or job['p'] == 'annually':
            schedule = 'OnCalendar=*-1-1 %s:%s:0' % (hour, delay)
        else:
            try:
               if int(job['p']) > 31:
                    # workaround for anacrontab
                    schedule = 'OnCalendar=*-1/%s-1 %s:%s:0' % (int(round(int(job['p']))/30), hour, delay)
               else:
                    schedule = 'OnCalendar=*-*-1/%s %s:%s:0' % (int(job['p']), hour, delay)
            except ValueError:
                    # this record is invalid, pass it as-is to systemd
                    # that will complain loudly in the journal;
                    # but the other lines are not affected
                    schedule = 'OnCalendar=%s' % job['p']

    else:
        dows = ','.join(job['w'])
        dows = '' if dows == '*' else dows + ' '

        schedule = 'OnCalendar=%s*-%s-%s %s:%s:00' % (dows, ','.join(map(str, job['M'])),
                ','.join(map(str, job['d'])), ','.join(map(str, job['h'])), ','.join(map(str, job['m'])))

    if 'p' in job and job['p'] == "hourly":
        persistent=''

    if ('p' not in job and
       job['M'] == ['*'] and
       job['w'] == ['*'] and
       job['d'] == ['*'] and
       job['h'] == ['*']):
        persistent=''

    with open('%s/%s.timer' % (TARGER_DIR, unit_name), 'w') as f:
        f.write('''# Automatically generated by %s

[Unit]
Description=[Cron] "%s"
PartOf=cron.target
RefuseManualStart=true
RefuseManualStop=true
SourcePath=%s

[Timer]
Unit=%s.service
%s
AccuracySec=%sm
%s
%s
''' % (SELF, job['l'], job['f'], unit_name, schedule, accuracy, persistent, boot))

    try:
        os.symlink('%s/%s.timer' % (TARGER_DIR, unit_name), '%s/%s.timer' % (TIMERS_DIR, unit_name))
    except OSError as e:
        if e.errno != os.errno.EEXIST:
            raise

    with open('%s/%s.service' % (TARGER_DIR, unit_name), 'w') as f:
        f.write('''# Automatically generated by %s

[Unit]
Description=[Cron] "%s"
RefuseManualStart=true
RefuseManualStop=true
SourcePath=%s

[Service]
Type=oneshot
User=%s
Environment=%s
ExecStart=%s
StandardOutput=%s
''' % (SELF, job['l'], job['f'], job['u'], job['e'], command, standardoutput))

    return '%s.timer' % unit_name


seqs = {}
def count():
    n = 0
    while True:
        yield n
        n += 1


for filename in CRONTAB_FILES:
    try:
        for job in parse_crontab(filename, withuser=True):
            generate_timer_unit(job, seqs.setdefault(job['u'], count()))
    except IOError:
        pass

for filename in ANACRONTAB_FILES:
    try:
        for job in parse_crontab(filename, monotonic=True):
            generate_timer_unit(job, seqs.setdefault(job['u'], count()))
    except IOError:
        pass

for filename in USERCRONTAB_FILES:
    try:
        for job in parse_crontab(filename, withuser=False):
            generate_timer_unit(job, seqs.setdefault(job['u'], count()))
    except IOError:
        pass

